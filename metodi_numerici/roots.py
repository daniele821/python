#!/bin/python3

import numpy as np
import math
import matplotlib.pyplot as plt


PAUSE = 1


def sign(x):
    return math.copysign(1, x)


def bisection(func, a, b, tolx):
    fa = func(a)
    fb = func(b)
    if sign(fa) * sign(fb) >= 0:
        raise ValueError('cannot apply bisection')
    it = 0
    vecx = []

    while abs(b - a) > tolx:
        x = a + (b - a) / 2
        vecx.append(x)
        fx = func(x)
        it += 1

        if abs(fx) <= np.spacing(1):
            break

        if sign(fa) * sign(fx) > 0:
            fa = fx
            a = x
        elif sign(fx) * sign(fb) > 0:
            fb = fx
            b = x

    return x, it, vecx


def falsi(func, a, b, tolx, tolf, itmax):
    fa = func(a)
    fb = func(b)
    fx = np.inf
    if sign(fa) * sign(fb) >= 0:
        raise ValueError('cannot apply falsi')
    it = 0
    vecx = []

    while abs(b - a) > tolx and abs(fx) >= tolf and it < itmax:
        x = a - fa * (b - a) / (fb - fa)
        vecx.append(x)
        fx = func(x)
        it += 1

        if abs(fx) <= np.spacing(1):
            break

        if sign(fa) * sign(fx) > 0:
            fa = fx
            a = x
        elif sign(fx) * sign(fb) > 0:
            fb = fx
            b = x

    return x, it, vecx


def animate(func, vecx, a, b):
    # extremes of the graph
    fa = func(a)
    fb = func(b)
    fx = np.linspace(a, b, 100)
    fy = func(fx)

    # not linear function for which we are calculating roots

    for x in vecx:
        plt.clf()
        plt.grid(True)

        # draw function in study
        plt.plot(fx, fy, 'r')

        # draw line
        y = func(x)
        plt.plot([a, b], [fa, fb], 'b')
        if sign(y) * sign(fa) > 0:
            fa = y
            a = x
        elif sign(y) * sign(fb) > 0:
            fb = y
            b = x

        plt.pause(PAUSE)
    plt.show()
